#!/usr/bin/env python3

import json
import sys
import os
import subprocess
from textwrap import indent
from pathlib import Path
import pypandoc

languages = ["bash", "python"]
o_sym = "<<"
c_sym = ">>"

# TODO ignore \< \>
# returns match (or None if there isn't one) and whether or not it is
#  string replacement or results of a string execution replacement. It
#  will return matches in a left to right order
def get_match(txt):
    cur = 0
    open_count = 0
    start = -1

    while cur < len(txt):
        if txt[cur:cur+2] == o_sym:
            if start == -1:
                start = cur
            open_count += 1
            cur += len(o_sym) - 1

        elif txt[cur:cur+2] == c_sym:
            open_count -= 1
            cur += len(c_sym) - 1

        if open_count < 1 and start != -1:
            match = parse_match(txt[start + len(c_sym) : cur - 1])
            if match is None:
                print(f"content internal to {o_sym} and {c_sym} is invalid: {txt[start:cur + len(c_sym) - 1]}")
                return None
            return match | {"full": txt[start:cur + len(c_sym) - 1],
                            "start": start,
                            "end": cur + len(c_sym) - 1}
        cur += 1

    return None

def parse_name(txt):
    cur = 0
    while cur < len(txt):
        if txt[cur] in [')', '}', '<', '>', '=', '"', ' ']:
            print(f'Bad char: {txt[cur]} while parsing name from: "{txt}"')
            return None, 0

        if txt[cur] in ['(', '{']:
            break

        cur += 1
    return txt[:cur], cur

def parse_exec(txt):
    if len(txt) == 0:
        print(f'name has zero length')
        return "", False, False

    if txt[-1:] == "'":
        if len(txt) == 1:
            print(f'name has zero length')
            return "", False, False

        return txt[:-1], True, True

    return txt, False, True

def parse_args(txt):
    if len(txt) == 0:
        return "", 0, True

    if txt[0] == '{':
        return "", 0, True

    if txt[0] != '(':
        print(f'Bad char: {txt[0]} while parsing args from: "{txt}"')
        return "", 0, False

    cur = 1
    open_count = 1
    while cur < len(txt):
        if txt[cur] == '(':
            open_count += 1
        elif txt[cur] == ')':
            open_count -= 1

        if open_count < 1:
            return txt[1:cur], cur + 1, True

        cur += 1

    return "", 0, False

def parse_default(txt):
    if len(txt) == 0:
        return "", 0, True

    if txt[0] != "{":
        print(f'Bad char: {txt[0]} while parsing default from: "{txt}"')
        return "", 0, False

    cur = 1
    open_count = 1
    while cur < len(txt):
        if txt[cur] == '{':
            open_count += 1
        elif txt[cur] == '}':
            open_count -= 1

        if open_count < 1:
            return txt[1:cur], cur + 1, True

        cur += 1

    return "", 0, False

def parse_match_new(txt):
    name, pos = parse_name(txt)
    if name is None:
        return None

    name, exec, success = parse_exec(name)
    if success == False:
        return None

    args, shift, success = parse_args(txt[pos:])
    if success == False:
        return None

    default, shift, success = parse_default(txt[pos+shift:])
    if success == False:
        return None

    return {"name": name,
            "exec": exec,
            "args": args,
            "default": default.strip('"')}

# TODO ignore \( \)
# TODO handle <<one>> ?
# TODO handle <<one=1>> with default value ?
def parse_match(txt):
    # determine if this is exec=True
    exec = False
    if len(txt) > 2 and txt[-3:] == ")()":
        exec = True
        txt = txt[:-2]   # chop off the end

    # parse name
    cur = txt.find("(")
    if cur == -1:
        return None

    end_args = txt.rfind(")", cur + 1)
    if end_args == -1:
        return None

    if len(txt) != end_args + 1:
        return None

    return {"name": txt[:cur],
            "exec": exec,
            "args": txt[cur+1:end_args],
            "default": None}

def add_pre_post(code, prefix, postfix):
    lines = code.split('\n')
    for i, line in enumerate(lines):
        lines[i] = prefix + line + postfix

    return '\n'.join(lines)

# TODO ignore \"
def arg_parse(arg_str):
    if arg_str == '':
        return {}

    arg_lst = arg_str.split("\"")

    args = {}
    i = 0
    while arg_lst[i] != "" and i < len(arg_lst):
        args[arg_lst[i].strip().strip("=").strip()] = arg_lst[i+1]
        i += 2

    return args

def insert_blk(txt, blk_txt, start, end):
    lbreak = txt.rfind("\n", 0, start)
    if lbreak == -1:
        lbreak = -1

    rbreak = txt.find("\n", end)
    if rbreak == -1:
        rbreak = len(txt)

    pre_post = add_pre_post(blk_txt, txt[lbreak + 1 : start], txt[end : rbreak])
    return txt[:lbreak + 1] + pre_post + txt[rbreak:]

def parse_runnable_attrib(val):
    if isinstance(val, bool):
        return val

    if isinstance(val, str):
        return val.lower() != "false" and val != "0" and val != ""

    return str(val).lower() != "false" and str(val) != "0" and val is not None

class CodeBlock:
    def __init__(self):
        self.name=None
        self.code=None
        self.lang=None
        self.cwd="."
        self.tangle_file=None
        self.is_runnable = False
        self.code_blocks = None
        self.docker_container=None

    def get_run_cmd(self, args={}):
        if not self.is_runnable:
            return None

        code = self.code_blocks.expand(self.code, args)
        if self.lang == "bash":
            cmd = code
        elif self.lang == "python":
            cmd = f"python3 -c '{code}'"
        else:
            print(f"language {self.lang} is not supported for execution")
            return

        if self.docker_container is not None:
            docker_container = self.code_blocks.expand(self.docker_container, args)
        cwd = self.code_blocks.expand(self.cwd, args)
        cmd_in_dir = f"cd {cwd}\n{cmd}"
        if self.docker_container is None:
            return cmd_in_dir
        else:
            return f'docker exec {docker_container} /bin/bash -c "{cmd_in_dir}"'

    def info(self):
        print(self)

    def run(self):
        cmd = self.get_run_cmd()
        if cmd is None:
            print("Error running command")
            return

        subprocess.call(cmd, shell=True)

    def run_return_results(self, args={}):
        cmd = self.get_run_cmd(args)
        if cmd is None:
            print("Error running command")
            return

        output = subprocess.run(cmd, capture_output=True, shell=True)
        return output.stdout.decode("utf-8")

    def tangle(self):
        if self.tangle_file is not None:
            tangle_file = self.code_blocks.expand(self.tangle_file)
            code = self.code_blocks.expand(self.code)

            f = open(tangle_file, "w")
            f.write(code)
            f.write("\n")  # put a newline at the end of the file
            f.close()

    def parse(self, the_json):
        self.code = the_json[1]

        for attrib in the_json[0][1]:
            if attrib in languages:
                self.lang = attrib

        for attrib in the_json[0][2]:
            if attrib[0] == "runnable":
                self.is_runnable = parse_runnable_attrib(attrib[1])
            elif attrib[0] == "lang":
                self.lang = attrib[1]
            elif attrib[0] == "name":
                self.name = attrib[1]
            elif attrib[0] == "dir":
                self.cwd = attrib[1]
            elif attrib[0] == "tangle":
                self.tangle_file = attrib[1]
            elif attrib[0] == "docker":
                self.docker_container = attrib[1]
            else:
                print(f"Warning: I don't know what attribute this is {attrib[0]}")

    def __repr__(self):
        out = "CodeBlock("
        if self.name is not None:
            out += f"name={self.name}, "
        if self.docker_container is not None:
            out += f"docker={self.code_blocks.expand(self.docker_container)}, "
        if self.lang is not None:
            out += f"lang={self.lang}, "
        out += f"dir={self.code_blocks.expand(self.cwd)}, "
        if self.is_runnable:
            out += f"runnable={self.is_runnable}, "
        out += ")\n"
        out += f"{{\n{indent(self.code_blocks.expand(self.code), '    ')}\n}}"
        return out

class CodeBlocks:
    def __init__(self, start_file):
        self.code_blocks = []
        self.md_files = [[start_file, False]]

    def add_md_file(self, filename):
        for f in self.md_files:
            if f[0] == filename:
                return

        self.md_files.append([filename, False])

    def get_next_unread(self):
        for f in self.md_files:
            if f[1] == False:
                f[1] = True
                return f[0]

        return None

    def parse(self):
        curr_file = self.get_next_unread()
        if curr_file is None:    # all done reading
            return

        self.parse_file(curr_file)
        self.parse()   # start over -- because new files might have gone into the list

    def parse_file(self, filename):
        data = json.loads(pypandoc.convert_file(filename, 'json'))
        self.parse_json(data)

    def parse_json(self, data):
        for section, constants in data['meta'].items():
            if section == "includes":
                for i in constants['c']:
                    self.add_md_file(i['c'][0]['c'])

            if section == "constants":
                for key, val in constants['c'].items():
                    cb = CodeBlock()
                    cb.name = key
                    cb.code = val['c'][0]['c']
                    cb.code_blocks = self
                    self.code_blocks.append(cb)

        for block in data['blocks']:
            if block['t'] == "CodeBlock":
                cb = CodeBlock()
                cb.parse(block['c'])
                cb.code_blocks = self

                # append the code block contents if the name is the same
                if cb.name is not None:
                    blk = self.get_code_block(cb.name)
                    if blk is not None:
                        cb.code = blk.code + "\n" + cb.code
                        self.code_blocks.remove(blk)

                self.code_blocks.append(cb)

    def print_summary(self):
        print("Commands:")
        for num, block in enumerate(self.code_blocks):
            if block.is_runnable:
                print(f"    {num}. {block.name}")

        print("\nFiles:")
        for num, block in enumerate(self.code_blocks):
            if block.tangle_file is not None:
                if block.name is None or block.name == "":
                    expanded_filename = self.expand(block.tangle_file)
                    rel_path = os.path.relpath(expanded_filename)
                    print(f"    {num}. {rel_path}")
                else:
                    print(f"    {num}. {block.name}")

    def get_code_block(self, name):
        for block in self.code_blocks:
            if block.name == name:
                return block
        return None

    def get_code_block_by_code(self, code):
        for block in self.code_blocks:
            if block.code == code:
                return block
        return None

    def replace_match(self, txt, match, args):
        def fn(replace_txt):
            return self.expand(insert_blk(txt,
                                          replace_txt,
                                          match["start"],
                                          match["end"]),
                               args)
        return fn

    def expand(self, txt, args={}):
        match = get_match(txt)
        if match is None:    # base case, exit point for the recursion
            return txt

        name = match["name"]
        new_args = arg_parse(match["args"])
        replace_fn = self.replace_match(txt, match, args | new_args)

        if args is not None and name in args:
            return replace_fn(args[name])

        blk = self.get_code_block(name)
        if blk is None:
            return replace_fn("")   # if block doesn't exist, return empty string

        if match["exec"]:
            return replace_fn(blk.run_return_results(args | new_args))

        return replace_fn(blk.code)

    def run_block_fn(self, identifier, fn):
        block = None
        if identifier.isdigit():
            block = self.code_blocks[int(identifier)]
        else:
            block = self.get_code_block(identifier)

        if block is None:
            print("Error")
            return

        fn(block)

    def run_all_blocks_fn(self, fn):
        for block in self.code_blocks:
            fn(block)

if __name__ == '__main__':
    code_blocks = CodeBlocks(os.getenv("OMD_ROOT_FILE", "LIT.md"))
    code_blocks.parse()

    if len(sys.argv) == 3:
        if sys.argv[1] == "tangle":
            code_blocks.run_block_fn(sys.argv[2], CodeBlock.tangle)
        elif sys.argv[1] == "run":
            code_blocks.run_block_fn(sys.argv[2], CodeBlock.run)
        elif sys.argv[1] == "info":
            code_blocks.run_block_fn(sys.argv[2], CodeBlock.info)

    elif len(sys.argv) == 2:
        if sys.argv[1] == "tangle":
            code_blocks.run_all_blocks_fn(CodeBlock.tangle)
        elif sys.argv[1] == "info":
            code_blocks.run_all_blocks_fn(CodeBlock.info)
    else:
        code_blocks.print_summary()
